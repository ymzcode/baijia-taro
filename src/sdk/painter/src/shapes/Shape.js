import array from"../util/array";import object from"../util/object";import constant from"../constant";import containLine from"../contain/line";import containRect from"../contain/rect";import getRectByPoints from"../function/getRectByPoints";function isValidStyle(t){return t&&"transparent"!==t}export default class Shape{constructor(t){object.extend(this,t)}isPointInPath(t,i,e){let s=this.getRect(t);return s.width||(s.x-=constant.SIZE_MIN/2,s.width=constant.SIZE_MIN),s.height||(s.y-=constant.SIZE_MIN/2,s.height=constant.SIZE_MIN),!!containRect(s,i,e)&&(isValidStyle(this.fillStyle)&&this.isPointInFill?this.isPointInFill(t,i,e):this.isPointInStroke(t,i,e))}isPointInStroke(t,i,e){let{lineWidth:s,points:n}=this;s<constant.SIZE_MIN&&(s=constant.SIZE_MIN);for(let t=0,o=n.length;t<o;t++)if(n[t+1]&&containLine(n[t].x,n[t].y,n[t+1].x,n[t+1].y,s*constant.DEVICE_PIXEL_RATIO,i,e))return!0;return!1}draw(t){const i=this.fill&&isValidStyle(this.fillStyle),e=this.lineWidth&&isValidStyle(this.strokeStyle);(i||e)&&(i&&(e||this.applyShadow(t),this.fill(t)),e&&(this.applyShadow(t),this.setLineStyle(t),this.stroke(t)),t.draw(!0))}drawPath(t){t.drawPoints(this.points)}stroke(t){t.setLineWidth(this.lineWidth),t.setStrokeStyle(this.strokeStyle),t.begin(),this.drawPath(t),this.autoClosePath&&t.close(),t.stroke()}applyShadow(t){this.shadowColor?t.enableShadow(this.shadowOffsetX,this.shadowOffsetY,this.shadowBlur,this.shadowColor):t.disableShadow()}setLineStyle(t){}save(t){return this.points.map(function(i){return{x:(i.x-t.x)/t.width,y:(i.y-t.y)/t.height}})}restore(t,i){array.each(this.points,function(e,s){e.x=t.x+t.width*i[s].x,e.y=t.y+t.height*i[s].y})}getRect(){return getRectByPoints(this.points)}clone(){return new this.constructor(object.copy(this,!0))}toJSON(t){let i={number:this.number,lineWidth:this.lineWidth,strokeStyle:this.strokeStyle,fillStyle:this.fillStyle};return this.points&&(i.points=this.points),t&&object.extend(i,t),i}};